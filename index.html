<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Privacy Avatar Cam v1.1</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (for JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        body {
            background-color: #000;
            color: white;
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- Icons (Replaced Lucide-react with inline SVGs) ---
        const Icon = ({ name, size = 24, className = "" }) => {
            const paths = {
                camera: "M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z M12 16a3 3 0 1 0 0-6 3 3 0 0 0 0 6",
                refreshCw: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8 M21 3v5h-5 M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16 M3 21v-5h5",
                upload: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4 M17 8l-5-5-5 5 M12 3v12",
                move: "M5 9l-3 3 3 3 M9 5l3-3 3 3 M19 9l3 3-3 3 M15 19l-3 3-3-3 M2 12h20 M12 2v20",
                eye: "M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6",
                eyeOff: "M9.88 9.88a3 3 0 1 0 4.24 4.24 M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68 M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7c.44 0 .87-.03 1.28-.08 M2 2l20 20",
                mic: "M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z M19 10v2a7 7 0 0 1-14 0v-2 M12 19v4 M8 23h8",
                smile: "M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z M8 14s1.5 2 4 2 4-2 4-2 M9 9h.01 M15 9h.01",
                settings: "M12.22 2h-.44a2 2 0 0 1-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6",
                arrowUp: "M12 19V5 M5 12l7-7 7 7",
                arrowDown: "M12 5v14 M19 12l-7 7-7-7",
                zoomIn: "M21 21l-4.35-4.35 M11 8v6 M8 11h6 M11 19a8 8 0 1 0 0-16 8 8 0 0 0 0 16z",
                sliders: "M4 21v-7 M4 10V3 M12 21v-9 M12 8V3 M20 21v-5 M20 12V3 M1 14h6 M9 8h6 M17 16h6",
                toggleLeft: "M16 6H8a6 6 0 1 0 0 12h8a6 6 0 0 0 0-12z M8 14a2 2 0 1 1 0-4 2 2 0 0 1 0 4z",
                toggleRight: "M16 6H8a6 6 0 1 0 0 12h8a6 6 0 0 0 0-12z M16 14a2 2 0 1 1 0-4 2 2 0 0 1 0 4z",
                x: "M18 6L6 18 M6 6l12 12",
                video: "M15 10l4.55-4.55A2 2 0 0 1 23 7v10a2 2 0 0 1-3.45 1.55L15 14 M21 7v10 M3 7h10a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2z",
                videoOff: "M2 2l20 20 M10.61 6.61A2 2 0 0 1 13 7h2a2 2 0 0 1 2 2v2.5l4.55-4.55A2 2 0 0 1 23 7v10a2.002 2.002 0 0 1-.4 1.2 M15 14v1a2 2 0 0 1-2 2H7.33 M1.11 9.11A2 2 0 0 0 1 11v6a2 2 0 0 0 2 2h8.72",
                clock: "M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z M12 6v6l4 2",
                userX: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2 M8 7a4 4 0 1 0 0-8 4 4 0 0 0 0 8z M17 8l5 5 M22 8l-5 5",
                layers: "M12 2L2 7l10 5 10-5-10-5z M2 17l10 5 10-5 M2 12l10 5 10-5",
                userMinus: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2 M8 7a4 4 0 1 0 0-8 4 4 0 0 0 0 8z M22 11h-6",
                scanEye: "M3 7V5a2 2 0 0 1 2-2h2 M17 3h2a2 2 0 0 1 2 2v2 M21 17v2a2 2 0 0 1-2 2h-2 M7 21H5a2 2 0 0 1-2-2v-2 M12 8a3 3 0 1 0 0 6 3 3 0 0 0 0-6z M2 12h20",
                scissors: "M6 9a3 3 0 1 0 0-6 3 3 0 0 0 0 6z M6 21a3 3 0 1 0 0-6 3 3 0 0 0 0 6z M20 12l-8.707-3.707a1 1 0 0 0-1.172.293l-2.414 2.414 M14.485 10l5.515 2",
                arrowUpFromLine: "M4 20h16 M12 16V4 M12 4L8 8 M12 4l4 4",
                info: "M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z M12 16v-4 M12 8h.01"
            };
            return (
                <svg 
                    xmlns="http://www.w3.org/2000/svg" 
                    width={size} 
                    height={size} 
                    viewBox="0 0 24 24" 
                    fill="none" 
                    stroke="currentColor" 
                    strokeWidth="2" 
                    strokeLinecap="round" 
                    strokeLinejoin="round" 
                    className={className}
                >
                    <path d={paths[name] || ""} />
                </svg>
            );
        };

        const DEFAULT_Placeholder = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200' viewBox='0 0 200 200'%3E%3Ccircle cx='100' cy='100' r='100' fill='%23fbbf24' /%3E%3Ccircle cx='65' cy='75' r='15' fill='%23000' /%3E%3Ccircle cx='135' cy='75' r='15' fill='%23000' /%3E%3Cpath d='M65 130 Q100 160 135 130' stroke='%23000' stroke-width='10' fill='none' /%3E%3C/svg%3E";

        const EXPRESSION_TYPES = {
            neutral: { id: 'neutral', label: '通常時', icon: 'smile' },
            winkLeft: { id: 'winkLeft', label: '左目閉じ', icon: 'eyeOff', iconClass: "scale-x-[-1]" },
            winkRight: { id: 'winkRight', label: '右目閉じ', icon: 'eyeOff' },
            mouthOpen: { id: 'mouthOpen', label: '口あけ', icon: 'mic' },
        };

        const FACE_OVAL_INDICES = [
            10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109
        ];

        // MediaPipe URLs (Latest)
        const MP_FACEMESH_URL = 'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js';
        const MP_SEGMENTATION_URL = 'https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js';
        const MP_CAMERA_URL = 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';

        const App = () => {
            const [images, setImages] = useState({
                neutral: null,
                winkLeft: null,
                winkRight: null,
                mouthOpen: null,
            });
            
            const [standbyImage, setStandbyImage] = useState(null);
            const [priorityOrder, setPriorityOrder] = useState(['mouthOpen', 'winkLeft', 'winkRight', 'neutral']);
            const [enabledExpressions, setEnabledExpressions] = useState({
                neutral: true,
                winkLeft: true,
                winkRight: true,
                mouthOpen: true,
            });

            const [config, setConfig] = useState({
                scale: 1.5,
                offsetX: 0,
                offsetY: 0,
                eyeClosedThreshold: 0.12,
                mouthOpenThreshold: 0.3,
                triggerDuration: 200,
                enableBodyMask: true,
                maskThreshold: 0.5,   
                faceHoleScale: 1.1,
                maskCutoffOffset: 0,
                showMaskDebug: false, 
            });

            const [showUI, setShowUI] = useState(true);
            const [isCameraOn, setIsCameraOn] = useState(false);
            const [isFaceDetected, setIsFaceDetected] = useState(false);
            const [isLoading, setIsLoading] = useState(true);
            const [errorMsg, setErrorMsg] = useState(null);
            const [currentExpression, setCurrentExpression] = useState('neutral');

            // Refs
            const configRef = useRef(config);
            const enabledExpressionsRef = useRef(enabledExpressions);
            const priorityOrderRef = useRef(priorityOrder);
            const standbyImageRef = useRef(null);
            const isCameraOnRef = useRef(isCameraOn); 

            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            
            const faceMeshRef = useRef(null);
            const selfieSegmentationRef = useRef(null);
            const cameraRef = useRef(null);
            
            const imagesRef = useRef({});
            const maskCanvasRef = useRef(null);
            const maskTempCanvasRef = useRef(null);
            const rawSegmentationCanvasRef = useRef(null);
            const latestSegmentationMaskRef = useRef(null);

            const isDraggingRef = useRef(false);
            const lastMousePosRef = useRef({ x: 0, y: 0 });
            const lastFaceWidthPxRef = useRef(100); 

            const pendingExpressionRef = useRef('neutral');
            const expressionDurationRef = useRef(0);
            const lastFrameTimeRef = useRef(0);

            // Effects
            useEffect(() => { configRef.current = config; }, [config]);
            useEffect(() => { enabledExpressionsRef.current = enabledExpressions; }, [enabledExpressions]);
            useEffect(() => { priorityOrderRef.current = priorityOrder; }, [priorityOrder]);
            useEffect(() => { isCameraOnRef.current = isCameraOn; }, [isCameraOn]);

            useEffect(() => {
                if (standbyImage) {
                    const img = new Image();
                    img.src = standbyImage;
                    standbyImageRef.current = img;
                } else {
                    standbyImageRef.current = null;
                }
            }, [standbyImage]);

            useEffect(() => {
                const preloadImg = new Image();
                preloadImg.src = DEFAULT_Placeholder;
                imagesRef.current['default'] = preloadImg;
            }, []);

            useEffect(() => {
                Object.keys(images).forEach(key => {
                    if (images[key]) {
                        const img = new Image();
                        img.src = images[key];
                        imagesRef.current[key] = img;
                    }
                });
            }, [images]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key.toLowerCase() === 'h') {
                        setShowUI(prev => !prev);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, []);

            useEffect(() => {
                const loadScript = (src) => {
                    return new Promise((resolve, reject) => {
                        if (document.querySelector(`script[src="${src}"]`)) {
                            resolve(true);
                            return;
                        }
                        const script = document.createElement('script');
                        script.src = src;
                        script.crossOrigin = 'anonymous';
                        script.onload = () => resolve(true);
                        script.onerror = () => reject(new Error(`Failed to load ${src}`));
                        document.body.appendChild(script);
                    });
                };

                const initMediaPipe = async () => {
                    try {
                        await Promise.all([
                            loadScript(MP_FACEMESH_URL),
                            loadScript(MP_SEGMENTATION_URL),
                            loadScript(MP_CAMERA_URL)
                        ]);
                        
                        setTimeout(setupMediaPipe, 1000);
                    } catch (err) {
                        console.error(err);
                        setErrorMsg('AIモデルの読み込みに失敗しました。リロードしてください。');
                        setIsLoading(false);
                    }
                };

                initMediaPipe();
            }, []);

            useEffect(() => {
                if (cameraRef.current) {
                    if (isCameraOn) {
                        cameraRef.current.start().catch((e) => {
                            console.error("Camera Start Error:", e);
                            setErrorMsg("カメラの起動に失敗しました: " + e.message);
                        });
                    } else {
                        if (videoRef.current && videoRef.current.srcObject) {
                            const stream = videoRef.current.srcObject;
                            stream.getTracks().forEach(track => track.stop());
                            videoRef.current.srcObject = null;
                        }
                        const ctx = canvasRef.current?.getContext('2d');
                        if (ctx && canvasRef.current) {
                            ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                        }
                        setIsFaceDetected(false);
                    }
                }
            }, [isCameraOn]);

            const setupMediaPipe = () => {
                if (!window.FaceMesh || !window.SelfieSegmentation || !window.Camera) {
                    setTimeout(setupMediaPipe, 500); 
                    return;
                }

                try {
                    const faceMesh = new window.FaceMesh({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                    });
                    faceMesh.setOptions({
                        maxNumFaces: 1,
                        refineLandmarks: false, 
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });
                    faceMesh.onResults(onFaceResults);
                    faceMeshRef.current = faceMesh;

                    const selfieSegmentation = new window.SelfieSegmentation({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`
                    });
                    selfieSegmentation.setOptions({
                        modelSelection: 1, 
                    });
                    selfieSegmentation.onResults(onSegmentationResults);
                    selfieSegmentationRef.current = selfieSegmentation;

                    if (videoRef.current) {
                        const camera = new window.Camera(videoRef.current, {
                            onFrame: async () => {
                                if (videoRef.current && isCameraOnRef.current) {
                                    if (videoRef.current.videoWidth === 0) return;
                                    try {
                                        if (faceMeshRef.current) {
                                            await faceMeshRef.current.send({ image: videoRef.current });
                                        }
                                        if (configRef.current.enableBodyMask && selfieSegmentationRef.current) {
                                            await selfieSegmentationRef.current.send({ image: videoRef.current });
                                        }
                                    } catch (e) {
                                        console.error("Pipe send error", e);
                                    }
                                }
                            },
                            width: 1280,
                            height: 720
                        });
                        cameraRef.current = camera;
                        setIsLoading(false);
                    }
                } catch (e) {
                    console.error("Setup error", e);
                    setErrorMsg("初期化エラー: " + e.message);
                }
            };

            const toggleCamera = () => {
                setIsCameraOn(prev => !prev);
            };

            const onSegmentationResults = (results) => {
                if (!rawSegmentationCanvasRef.current) {
                    rawSegmentationCanvasRef.current = document.createElement('canvas');
                    rawSegmentationCanvasRef.current.width = results.segmentationMask.width;
                    rawSegmentationCanvasRef.current.height = results.segmentationMask.height;
                }
                const rawCanvas = rawSegmentationCanvasRef.current;
                const ctx = rawCanvas.getContext('2d');
                if (ctx) {
                    ctx.clearRect(0, 0, rawCanvas.width, rawCanvas.height);
                    ctx.drawImage(results.segmentationMask, 0, 0, rawCanvas.width, rawCanvas.height);
                }
            };

            const distance = (p1, p2) => {
                return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            };

            const onFaceResults = (results) => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                const width = canvas.width;
                const height = canvas.height;
                const now = Date.now();

                if (!maskCanvasRef.current) maskCanvasRef.current = document.createElement('canvas');
                if (maskCanvasRef.current.width !== width || maskCanvasRef.current.height !== height) {
                    maskCanvasRef.current.width = width;
                    maskCanvasRef.current.height = height;
                }
                if (!maskTempCanvasRef.current) maskTempCanvasRef.current = document.createElement('canvas');
                if (maskTempCanvasRef.current.width !== 320 || maskTempCanvasRef.current.height !== 180) {
                    maskTempCanvasRef.current.width = 320;
                    maskTempCanvasRef.current.height = 180;
                }

                ctx.save();
                ctx.clearRect(0, 0, width, height);

                const hasFace = results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0;
                setIsFaceDetected(hasFace);

                if (!hasFace) {
                    ctx.restore(); 
                    ctx.fillStyle = "black";
                    ctx.fillRect(0, 0, width, height);
                    ctx.save();
                    ctx.translate(width, 0);
                    ctx.scale(-1, 1);
                    if (standbyImageRef.current && standbyImageRef.current.complete) {
                        const img = standbyImageRef.current;
                        const imgRatio = img.width / img.height;
                        const canvasRatio = width / height;
                        let drawW, drawH, drawX, drawY;
                        if (canvasRatio > imgRatio) {
                            drawW = width;
                            drawH = width / imgRatio;
                            drawX = 0;
                            drawY = (height - drawH) / 2;
                        } else {
                            drawH = height;
                            drawW = height * imgRatio;
                            drawY = 0;
                            drawX = (width - drawW) / 2;
                        }
                        ctx.drawImage(img, drawX, drawY, drawW, drawH);
                    } else {
                        ctx.fillStyle = "#333";
                        ctx.font = "bold 30px sans-serif";
                        ctx.textAlign = "center";
                        ctx.fillText("WAITING FOR FACE...", width / 2, height / 2);
                    }
                    ctx.restore(); 
                    return; 
                }

                ctx.save();
                ctx.translate(width, 0);
                ctx.scale(-1, 1);
                ctx.drawImage(results.image, 0, 0, width, height);
                ctx.restore();

                const landmarks = results.multiFaceLandmarks[0];
                // ★ 位置計算ロジックの修正 ★
                // 鼻先(1)ではなく、耳付近(234, 454)の中点を使って、顔の回転による位置ずれを軽減する
                const leftSide = landmarks[234];
                const rightSide = landmarks[454];
                
                // 座標計算
                // ビデオは左右反転(scaleX -1)で描画しているが、座標系はそのまま
                // 中央値を使うことで、顔を横に向けた時の「鼻の移動」によるズレを抑える
                const midX = (leftSide.x + rightSide.x) / 2;
                const midY = (leftSide.y + rightSide.y) / 2;
                
                const faceWidthRel = distance(leftSide, rightSide);
                const faceWidthPx = faceWidthRel * width;
                lastFaceWidthPxRef.current = faceWidthPx;

                // 回転角度計算（これは目の位置を使うのが一般的）
                const dx = landmarks[263].x - landmarks[33].x;
                const dy = landmarks[263].y - landmarks[33].y;
                const angle = Math.atan2(dy, dx); 

                // 描画中心座標
                const x = midX * width;
                const y = midY * height;

                const rEyeH = distance(landmarks[33], landmarks[133]);
                const rEyeV = distance(landmarks[159], landmarks[145]);
                const rightEAR = rEyeV / rEyeH;
                const lEyeH = distance(landmarks[362], landmarks[263]);
                const lEyeV = distance(landmarks[386], landmarks[374]);
                const leftEAR = lEyeV / lEyeH;
                const mouthH = distance(landmarks[78], landmarks[308]);
                const mouthV = distance(landmarks[13], landmarks[14]);
                const mouthRatio = mouthV / mouthH;

                const { eyeClosedThreshold, mouthOpenThreshold, triggerDuration, enableBodyMask, maskThreshold, faceHoleScale, showMaskDebug, maskCutoffOffset } = configRef.current;
                
                let detectedState = 'neutral';
                for (const key of priorityOrderRef.current) {
                    if (!enabledExpressionsRef.current[key]) continue;
                    if (key === 'mouthOpen' && mouthRatio > mouthOpenThreshold) { detectedState = 'mouthOpen'; break; }
                    if (key === 'winkLeft' && (leftEAR < eyeClosedThreshold) && !(rightEAR < eyeClosedThreshold)) { detectedState = 'winkLeft'; break; }
                    if (key === 'winkRight' && (rightEAR < eyeClosedThreshold) && !(leftEAR < eyeClosedThreshold)) { detectedState = 'winkRight'; break; }
                    if (key === 'neutral') { detectedState = 'neutral'; break; }
                }

                if (detectedState === pendingExpressionRef.current) {
                    if (lastFrameTimeRef.current > 0) expressionDurationRef.current += (now - lastFrameTimeRef.current);
                } else {
                    pendingExpressionRef.current = detectedState;
                    expressionDurationRef.current = 0;
                }
                lastFrameTimeRef.current = now;
                
                let finalState = currentExpression;
                if (expressionDurationRef.current >= triggerDuration) {
                    setCurrentExpression(pendingExpressionRef.current);
                    finalState = pendingExpressionRef.current;
                }

                const imgToDraw = imagesRef.current[finalState] || imagesRef.current['neutral'] || imagesRef.current['default'];
                if (imgToDraw && imgToDraw.complete) {
                    const size = faceWidthPx * configRef.current.scale;
                    ctx.save();
                    const offsetX = configRef.current.offsetX * (faceWidthPx / 100); 
                    const offsetY = configRef.current.offsetY * (faceWidthPx / 100);
                    
                    // ビデオが反転しているので、座標xは「画面右端からの距離」になるイメージ
                    // xは0-1正規化座標*width。
                    ctx.translate(width - x + offsetX, y + offsetY); 
                    ctx.rotate(-angle); 
                    ctx.drawImage(imgToDraw, -size / 2, -size / 2, size, size);
                    ctx.restore();
                }

                if (enableBodyMask && rawSegmentationCanvasRef.current && maskCanvasRef.current && maskTempCanvasRef.current) {
                    const mCtx = maskCanvasRef.current.getContext('2d');
                    const tCtx = maskTempCanvasRef.current.getContext('2d');
                    
                    if (mCtx && tCtx) {
                        const tW = maskTempCanvasRef.current.width;
                        const tH = maskTempCanvasRef.current.height;
                        tCtx.clearRect(0, 0, tW, tH);
                        
                        tCtx.save();
                        tCtx.translate(tW, 0);
                        tCtx.scale(-1, 1);
                        tCtx.drawImage(rawSegmentationCanvasRef.current, 0, 0, tW, tH);
                        tCtx.restore();

                        const imageData = tCtx.getImageData(0, 0, tW, tH);
                        const data = imageData.data;
                        const thresholdVal = maskThreshold * 255; 

                        for (let i = 0; i < data.length; i += 4) {
                            const confidence = data[i]; 
                            if (confidence > thresholdVal) {
                                if (showMaskDebug) {
                                    data[i] = 255; data[i+1] = 0; data[i+2] = 0; data[i+3] = 150;
                                } else {
                                    data[i] = 255; data[i+1] = 255; data[i+2] = 255; data[i+3] = 255; 
                                }
                            } else {
                                data[i + 3] = 0;   
                            }
                        }
                        tCtx.putImageData(imageData, 0, 0);

                        if (faceHoleScale > 0) {
                            tCtx.globalCompositeOperation = 'destination-out'; 
                            tCtx.beginPath();
                            const firstPt = landmarks[FACE_OVAL_INDICES[0]];
                            const fx = (1 - firstPt.x) * tW; 
                            const fy = firstPt.y * tH;
                            tCtx.moveTo(fx, fy);
                            let centerX = 0, centerY = 0;
                            FACE_OVAL_INDICES.forEach(idx => { centerX += (1 - landmarks[idx].x) * tW; centerY += landmarks[idx].y * tH; });
                            centerX /= FACE_OVAL_INDICES.length; centerY /= FACE_OVAL_INDICES.length;
                            let maxY = 0; 
                            for (let i = 0; i < FACE_OVAL_INDICES.length; i++) {
                                const pt = landmarks[FACE_OVAL_INDICES[i]];
                                const px = (1 - pt.x) * tW;
                                const py = pt.y * tH;
                                const vecX = px - centerX;
                                const vecY = py - centerY;
                                const sx = centerX + vecX * faceHoleScale;
                                const sy = centerY + vecY * faceHoleScale;
                                if (sy > maxY) maxY = sy;
                                tCtx.lineTo(sx, sy);
                            }
                            tCtx.closePath();
                            tCtx.fill(); 
                            const cutLineY = maxY + maskCutoffOffset;
                            tCtx.fillRect(0, 0, tW, cutLineY);
                            tCtx.globalCompositeOperation = 'source-over'; 
                        }
                        mCtx.clearRect(0, 0, width, height);
                        mCtx.drawImage(maskTempCanvasRef.current, 0, 0, width, height);

                        if (showMaskDebug) {
                            ctx.drawImage(maskCanvasRef.current, 0, 0);
                        } else {
                            mCtx.globalCompositeOperation = 'source-in';
                            mCtx.save();
                            mCtx.translate(width, 0);
                            mCtx.scale(-1, 1);
                            mCtx.drawImage(results.image, 0, 0, width, height);
                            mCtx.restore();
                            mCtx.globalCompositeOperation = 'source-over';
                            ctx.drawImage(maskCanvasRef.current, 0, 0);
                        }
                    }
                }
                ctx.restore(); 
            };

            const handleImageUpload = (e, key) => {
                const file = e.target.files?.[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => setImages(prev => ({ ...prev, [key]: evt.target?.result }));
                    reader.readAsDataURL(file);
                }
            };

            const handleStandbyImageUpload = (e) => {
                const file = e.target.files?.[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => setStandbyImage(evt.target?.result);
                    reader.readAsDataURL(file);
                }
            };

            const movePriority = (index, direction) => {
                const newOrder = [...priorityOrder];
                if (direction === 'up' && index > 0) {
                    [newOrder[index], newOrder[index - 1]] = [newOrder[index - 1], newOrder[index]];
                } else if (direction === 'down' && index < newOrder.length - 1) {
                    [newOrder[index], newOrder[index + 1]] = [newOrder[index + 1], newOrder[index]];
                }
                setPriorityOrder(newOrder);
            };

            const toggleExpression = (key) => {
                setEnabledExpressions(prev => ({ ...prev, [key]: !prev[key] }));
            };

            const handleMouseDown = (e) => {
                isDraggingRef.current = true;
                lastMousePosRef.current = { x: e.clientX, y: e.clientY };
            };

            const handleMouseMove = (e) => {
                if (!isDraggingRef.current) return;
                const dx = e.clientX - lastMousePosRef.current.x;
                const dy = e.clientY - lastMousePosRef.current.y;
                lastMousePosRef.current = { x: e.clientX, y: e.clientY };
                const pxPerUnit = lastFaceWidthPxRef.current / 100;
                if (pxPerUnit < 0.1) return;
                setConfig(prev => ({
                    ...prev,
                    offsetX: prev.offsetX - (dx / pxPerUnit), 
                    offsetY: prev.offsetY + (dy / pxPerUnit), 
                }));
            };

            const handleMouseUp = () => { isDraggingRef.current = false; };

            const handleWheel = (e) => {
                const delta = e.deltaY;
                const zoomFactor = 0.1;
                setConfig(prev => {
                    let newScale = prev.scale - (delta > 0 ? zoomFactor : -zoomFactor);
                    newScale = Math.max(0.5, Math.min(newScale, 5.0));
                    return { ...prev, scale: newScale };
                });
            };

            return (
                <div className="relative w-screen h-screen bg-black overflow-hidden" onMouseUp={handleMouseUp}>
                    <video ref={videoRef} className="absolute opacity-0 pointer-events-none" playsInline muted width="1280" height="720" />
                    <div className="absolute inset-0 cursor-move group">
                        <canvas 
                            ref={canvasRef} 
                            className="w-full h-full object-contain transform scale-x-[-1]" 
                            width="1280" 
                            height="720" 
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseLeave={handleMouseUp}
                            onWheel={handleWheel}
                        />
                        {!isCameraOn && (
                            <div className="absolute inset-0 flex items-center justify-center bg-black/80 z-20 pointer-events-none">
                                <div className="flex flex-col items-center gap-3 text-gray-500/50">
                                    <Icon name="videoOff" size={64} />
                                    <span className="text-2xl font-bold tracking-widest">CAMERA OFF</span>
                                    <span className="text-sm">設定パネルからONにしてください</span>
                                </div>
                            </div>
                        )}
                        {isCameraOn && !isFaceDetected && !isLoading && (
                            <div className="absolute top-10 left-1/2 transform -translate-x-1/2 bg-red-900/50 text-red-200 px-4 py-1 rounded-full text-xs font-bold border border-red-500/30 z-20 pointer-events-none animate-pulse">
                                顔を認識できません（待機画面中）
                            </div>
                        )}
                        {showUI && isCameraOn && (
                            <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-black/50 text-white text-[10px] px-3 py-1 rounded-full opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap z-10 border border-white/20">
                                ドラッグ: 位置 / ホイール: 拡大 / Hキー: UI切替
                            </div>
                        )}
                    </div>

                    {isLoading && (
                        <div className="absolute inset-0 flex flex-col items-center justify-center bg-gray-900/90 text-white z-50">
                            <Icon name="refreshCw" className="animate-spin mb-4 text-blue-500" size={40} />
                            <p>AIモデルを読み込んでいます...</p>
                            <p className="text-sm text-gray-500 mt-2">（初回のみロードに時間がかかります）</p>
                        </div>
                    )}
                    
                    {errorMsg && (
                        <div className="absolute inset-0 flex items-center justify-center bg-red-900/90 text-white z-50 p-6 text-center">
                            <p>{errorMsg}</p>
                        </div>
                    )}

                    {showUI && (
                        <>
                            {isCameraOn && isFaceDetected && (
                                <div className="absolute top-4 left-4 bg-black/60 backdrop-blur-md px-4 py-2 rounded-full text-sm font-mono text-green-400 border border-white/10 flex items-center gap-3 shadow-lg z-30">
                                    <span className={`w-2.5 h-2.5 rounded-full ${currentExpression !== 'neutral' ? 'bg-green-500 animate-pulse' : 'bg-gray-500'}`}></span>
                                    <span className="font-bold">{EXPRESSION_TYPES[currentExpression]?.label}</span>
                                    <span className="text-[10px] text-gray-500">v1.1</span>
                                </div>
                            )}

                            <div className="absolute top-4 right-4 bottom-4 w-80 bg-gray-900/85 backdrop-blur-md border border-gray-700/50 rounded-2xl shadow-2xl flex flex-col overflow-hidden z-30 transition-all duration-300">
                                <div className="p-4 border-b border-gray-700/50 flex items-center justify-between bg-gray-800/50">
                                    <div className="flex items-center gap-2">
                                        <Icon name="camera" size={18} className="text-blue-400" />
                                        <span className="font-bold text-sm tracking-wide">設定 (Hide: 'H')</span>
                                    </div>
                                    <button onClick={() => setShowUI(false)} className="text-gray-400 hover:text-white transition-colors">
                                        <Icon name="x" size={18} />
                                    </button>
                                </div>

                                <div className="flex-1 overflow-y-auto custom-scrollbar p-3">
                                    <div className="mb-4 p-3 bg-gray-800/50 rounded-lg border border-gray-700/50">
                                        <div className="flex items-center justify-between mb-3 pb-3 border-b border-gray-700/50">
                                            <div className="flex items-center gap-2 text-gray-300">
                                                <Icon name={isCameraOn ? "video" : "videoOff"} size={16} className={isCameraOn ? "text-green-400" : "text-red-400"} />
                                                <span className="text-xs font-bold">カメラ映像</span>
                                            </div>
                                            <button
                                                onClick={toggleCamera}
                                                className={`flex items-center gap-2 px-3 py-1 rounded-full text-[10px] font-bold transition-all ${isCameraOn ? 'bg-green-500/20 text-green-400 border border-green-500/30 hover:bg-green-500/30' : 'bg-red-500/20 text-red-400 border border-red-500/30 hover:bg-red-500/30'}`}
                                            >
                                                {isCameraOn ? 'ON' : 'OFF'}
                                            </button>
                                        </div>
                                        
                                        <div className="space-y-3">
                                             <div className="flex items-center justify-between">
                                                 <div className="flex items-center gap-2 text-gray-300">
                                                    <Icon name="layers" size={16} className={config.enableBodyMask ? "text-purple-400" : "text-gray-500"} />
                                                    <span className="text-xs font-bold">身体マスク (手前表示)</span>
                                                 </div>
                                                 <button
                                                    onClick={() => setConfig(prev => ({...prev, enableBodyMask: !prev.enableBodyMask}))}
                                                    className={`flex items-center gap-2 px-3 py-1 rounded-full text-[10px] font-bold transition-all ${config.enableBodyMask ? 'bg-purple-500/20 text-purple-400 border border-purple-500/30 hover:bg-purple-500/30' : 'bg-gray-700 text-gray-400 border border-gray-600 hover:bg-gray-600'}`}
                                                >
                                                    {config.enableBodyMask ? 'ON' : 'OFF'}
                                                </button>
                                             </div>
                                             
                                             {config.enableBodyMask && (
                                                 <div className="bg-black/30 p-2 rounded space-y-2">
                                                    <div className="space-y-1">
                                                        <div className="flex justify-between text-[10px] text-gray-400">
                                                            <span>マスク範囲 (Threshold)</span>
                                                            <span>{config.maskThreshold.toFixed(2)}</span>
                                                        </div>
                                                        <input type="range" min="0.1" max="0.9" step="0.05" value={config.maskThreshold} onChange={(e) => setConfig({...config, maskThreshold: parseFloat(e.target.value)})} className="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-purple-500" />
                                                    </div>
                                                    <div className="space-y-1">
                                                        <div className="flex justify-between text-[10px] text-gray-400">
                                                            <span className="flex items-center gap-1"><Icon name="userMinus" size={10}/> 顔くり抜きサイズ (Face Scale)</span>
                                                            <span>{config.faceHoleScale.toFixed(1)}x</span>
                                                        </div>
                                                        <input type="range" min="0.0" max="2.0" step="0.1" value={config.faceHoleScale} onChange={(e) => setConfig({...config, faceHoleScale: parseFloat(e.target.value)})} className="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-purple-500" />
                                                    </div>
                                                    
                                                     <div className="space-y-1 pt-2 mt-1 border-t border-white/10">
                                                        <div className="flex justify-between text-[10px] text-gray-400">
                                                            <span className="flex items-center gap-1"><Icon name="scissors" size={10}/> マスク削除ライン (Cutoff Y)</span>
                                                            <span>{config.maskCutoffOffset}px</span>
                                                        </div>
                                                        <input type="range" min="-100" max="100" step="1" value={config.maskCutoffOffset} onChange={(e) => setConfig({...config, maskCutoffOffset: parseInt(e.target.value)})} className="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-blue-400" />
                                                        <p className="text-[8px] text-gray-500">あごの位置(0)から上下に削除ラインを調整します</p>
                                                    </div>

                                                    <div className="flex items-center justify-between pt-1 mt-1 border-t border-white/10">
                                                        <span className="flex items-center gap-1 text-[10px] text-red-300"><Icon name="scanEye" size={10}/> 赤色表示(Debug)</span>
                                                        <button
                                                            onClick={() => setConfig(prev => ({...prev, showMaskDebug: !prev.showMaskDebug}))}
                                                            className={`text-[10px] font-bold transition-colors ${config.showMaskDebug ? 'text-red-400' : 'text-gray-600'}`}
                                                        >
                                                            {config.showMaskDebug ? <Icon name="toggleRight" size={20} /> : <Icon name="toggleLeft" size={20} />}
                                                        </button>
                                                    </div>
                                                 </div>
                                             )}
                        </div>
                    </div>

                    <div className="mb-4 p-3 bg-gray-800/50 rounded-lg border border-gray-700/50">
                        <div className="flex items-center gap-2 text-gray-300 mb-2">
                             <Icon name="userX" size={16} className="text-orange-400" />
                             <span className="text-xs font-bold">待機画像 (顔ロスト時)</span>
                        </div>
                        <div className="flex items-center gap-3">
                             <div className="w-10 h-10 bg-black/40 rounded border border-gray-600/50 overflow-hidden flex-shrink-0 relative">
                                {standbyImage ? (
                                    <img src={standbyImage} alt="" className="w-full h-full object-cover" />
                                ) : (
                                    <div className="w-full h-full flex items-center justify-center text-[8px] text-gray-500 text-center">No Img<br/>(Black)</div>
                                )}
                            </div>
                            <label className="flex-1 cursor-pointer">
                                <div className="bg-gray-700 hover:bg-gray-600 text-[10px] text-center py-1.5 rounded border border-gray-600/30 text-gray-300 transition-colors">
                                    画像を設定
                                </div>
                                <input type="file" accept="image/*" className="hidden" onChange={handleStandbyImageUpload} />
                            </label>
                            {standbyImage && (
                                <button onClick={() => setStandbyImage(null)} className="text-[10px] text-red-400 hover:text-red-300">削除</button>
                            )}
                        </div>
                    </div>

                    <div className="mb-6">
                        <h3 className="text-[10px] font-bold text-gray-400 uppercase tracking-wider mb-3 px-1 flex items-center gap-2">
                            <Icon name="toggleLeft" size={12}/> 表情認識設定 (優先度順)
                        </h3>
                        <div className="space-y-2">
                            {priorityOrder.map((key, index) => (
                                <div key={key} className={`bg-black/40 rounded-lg p-2 border transition-all ${
                                    !enabledExpressions[key] ? 'border-gray-800 opacity-60' :
                                    (isCameraOn && isFaceDetected && key === currentExpression) ? 'border-green-500/60 shadow-[0_0_8px_rgba(34,197,94,0.15)] bg-green-900/10' : 'border-gray-700 hover:border-blue-500/30'
                                }`}>
                                    <div className="flex items-center justify-between mb-2">
                                        <div className="flex items-center gap-2">
                                            <span className="w-5 h-5 flex items-center justify-center bg-gray-800 rounded text-[10px] text-gray-400 font-mono">
                                                {index + 1}
                                            </span>
                                            <div className="flex items-center gap-2">
                                                <span className={`${enabledExpressions[key] ? 'text-gray-200' : 'text-gray-500'}`}>
                                                    <Icon name={EXPRESSION_TYPES[key].icon} size={18} className={EXPRESSION_TYPES[key].iconClass} />
                                                </span>
                                                <span className={`text-xs font-medium ${enabledExpressions[key] ? 'text-gray-200' : 'text-gray-500'}`}>
                                                    {EXPRESSION_TYPES[key].label}
                                                </span>
                                            </div>
                                        </div>
                                        <button 
                                            onClick={() => toggleExpression(key)}
                                            className={`transition-colors ${enabledExpressions[key] ? 'text-green-400' : 'text-gray-600'}`}
                                        >
                                            {enabledExpressions[key] ? <Icon name="toggleRight" size={22} /> : <Icon name="toggleLeft" size={22} />}
                                        </button>
                                    </div>
                                    <div className="flex items-center gap-2 pl-7">
                                        <div className="w-8 h-8 bg-gray-800 rounded border border-gray-600/50 overflow-hidden relative">
                                            {images[key] ? (
                                                <img src={images[key]} alt="" className="w-full h-full object-cover" />
                                            ) : (
                                                <div className="w-full h-full flex items-center justify-center"><span className="text-[8px] text-gray-500">None</span></div>
                                            )}
                                        </div>
                                        <label className="flex-1 cursor-pointer">
                                            <div className="bg-gray-800 hover:bg-gray-700 text-[10px] text-center py-1 rounded border border-gray-600/30 text-gray-400 hover:text-white transition-colors">
                                                画像変更
                                            </div>
                                            <input type="file" accept="image/*" className="hidden" onChange={(e) => handleImageUpload(e, key)} />
                                        </label>
                                        <div className="flex flex-col gap-0.5">
                                            <button onClick={() => movePriority(index, 'up')} disabled={index === 0} className="text-gray-500 hover:text-blue-400 disabled:opacity-20"><Icon name="arrowUp" size={12}/></button>
                                            <button onClick={() => movePriority(index, 'down')} disabled={index === priorityOrder.length - 1} className="text-gray-500 hover:text-blue-400 disabled:opacity-20"><Icon name="arrowDown" size={12}/></button>
                                        </div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="p-2 border-t border-gray-700/50 pt-4">
                        <h3 className="text-[10px] font-bold text-gray-400 uppercase tracking-wider mb-3 px-1 flex items-center gap-2">
                            <Icon name="sliders" size={12} /> 調整設定
                        </h3>

                        <div className="space-y-4 mb-6 bg-black/20 p-3 rounded-lg">
                            <div className="space-y-1 pb-3 border-b border-white/5">
                                <div className="flex justify-between text-[10px] text-blue-300">
                                    <span className="flex items-center gap-1"><Icon name="clock" size={10}/> 認識待機時間 (瞬き防止)</span>
                                    <span>{config.triggerDuration} ms</span>
                                </div>
                                <input type="range" min="0" max="1000" step="50" value={config.triggerDuration} onChange={(e) => setConfig({...config, triggerDuration: parseInt(e.target.value)})} className="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-400" />
                            </div>

                            <div className="space-y-1">
                                <div className="flex justify-between text-[10px] text-gray-400"><span>目の閉じ感度</span><span>{config.eyeClosedThreshold.toFixed(2)}</span></div>
                                <input type="range" min="0.05" max="0.7" step="0.01" value={config.eyeClosedThreshold} onChange={(e) => setConfig({...config, eyeClosedThreshold: parseFloat(e.target.value)})} className="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-green-500" />
                            </div>
                            <div className="space-y-1">
                                <div className="flex justify-between text-[10px] text-gray-400"><span>口の開き感度</span><span>{config.mouthOpenThreshold.toFixed(2)}</span></div>
                                <input type="range" min="0.1" max="0.8" step="0.05" value={config.mouthOpenThreshold} onChange={(e) => setConfig({...config, mouthOpenThreshold: parseFloat(e.target.value)})} className="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-green-500" />
                            </div>
                        </div>

                        <div className="space-y-3 px-1">
                            <div className="space-y-1">
                                <div className="flex justify-between text-[10px] text-gray-400"><span>サイズ (Scale)</span><span>{config.scale.toFixed(1)}x</span></div>
                                <input type="range" min="0.5" max="4.0" step="0.1" value={config.scale} onChange={(e) => setConfig({...config, scale: parseFloat(e.target.value)})} className="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500" />
                            </div>
                            <div className="grid grid-cols-2 gap-2">
                                <div className="space-y-1">
                                    <div className="flex justify-between text-[10px] text-gray-400"><span>Pos X</span><span>{config.offsetX.toFixed(0)}</span></div>
                                    <input type="range" min="-200" max="200" value={config.offsetX} onChange={(e) => setConfig({...config, offsetX: parseFloat(e.target.value)})} className="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500" />
                                </div>
                                <div className="space-y-1">
                                    <div className="flex justify-between text-[10px] text-gray-400"><span>Pos Y</span><span>{config.offsetY.toFixed(0)}</span></div>
                                    <input type="range" min="-200" max="200" value={config.offsetY} onChange={(e) => setConfig({...config, offsetY: parseFloat(e.target.value)})} className="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500" />
                                </div>
                            </div>
                        </div>

                         <div className="mt-6 flex">
                            <button 
                            onClick={() => setConfig({ scale: 1.5, offsetX: 0, offsetY: 0, eyeClosedThreshold: 0.12, mouthOpenThreshold: 0.3, triggerDuration: 200, enableBodyMask: true, maskThreshold: 0.5, faceHoleScale: 1.1, showMaskDebug: false, maskCutoffOffset: 0 })}
                            className="flex-1 bg-gray-800 hover:bg-gray-700 text-[10px] py-2 rounded text-gray-400 transition-colors border border-gray-700"
                            >
                            設定リセット
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </>
      )}
    </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
